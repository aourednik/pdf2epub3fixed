"""
Copyright (C) 2024 André Ourednik and Contributors

Permission is hereby granted to use this script for any purpose, including preparing production-ready documents, provided the following conditions are met:

1. You may not redistribute or sell this script or any derived software based on this script, in part or in whole, for commercial purposes without prior written permission from the original author, André Ourednik.

2. Redistribution of this script, with or without modifications, must retain this copyright notice and terms. Modifications must include a notice identifying the contributing authors and a summary of the changes made.

3. Contributors grant joint copyright ownership of their contributions to the original author (André Ourednik), ensuring that this script and all derived works remain under these terms.

This license does not restrict the use of outputs or products generated by this script, provided the script itself is not redistributed or sold.

Author: André Ourednik
Contributors: [Add your name here if you contribute to this script]
"""

import os
import sys
import zipfile
import shutil
import fitz  # PyMuPDF package for PDF processing
from PIL import Image # pillow package
import io
import json
import base64
from datetime import datetime

# import config parameters
from config import *

# Check if pdf_path is set
try: pdf_path
except NameError :
    sys.stderr.write("ERROR: You need to indicate a PDF file in the config.py\n")

# Set default values for other variables if they are None
try: epub_file_name 
except NameError :
    epub_file_name = os.path.splitext(pdf_path)[0]
    sys.stderr.write("Warning: epub_file_name is not set. Defaulting to pdf_path.\n")
try: title 
except NameError :
    title = "Default Title"
    sys.stderr.write("Warning: title is not set. Defaulting to 'Default Title'.\n")
try: author
except NameError: 
    author = "Unknown Author"
    sys.stderr.write("Warning: author is not set. Defaulting to 'Unknown Author'.\n")
try: language 
except NameError :
    language = "en"
    sys.stderr.write("Warning: language is not set. Defaulting to 'en'.\n")
try: publisher 
except NameError :
    publisher = "Unknown Publisher"
    sys.stderr.write("Warning: publisher is not set. Defaulting to 'Unknown Publisher'.\n")
try: date 
except NameError :
    date = "2024-01-01"
    sys.stderr.write("Warning: date is not set. Defaulting to '2024-01-01'.\n")
try: description 
except NameError :
    description = "No description available."
    sys.stderr.write("Warning: description is not set. Defaulting to 'No description available'.\n")
try: rights 
except NameError :
    rights = "All rights reserved."
    sys.stderr.write("Warning: rights is not set. Defaulting to 'All rights reserved'.\n")
try: font_folder 
except NameError :
    font_folder = "./fonts"
    sys.stderr.write("Warning: font_folder is not set. Defaulting to './fonts'.\n")
try: cover_image 
except NameError :
    cover_image = ""
    sys.stderr.write("Warning: cover_image is not set.\n")
try: urn 
except NameError :
    urn = "urn:default"
    sys.stderr.write("Warning: urn is not set. Defaulting to 'urn:default'.\n")

output_folder_html = os.path.join("output",epub_file_name + "_html")
output_folder_pageimages = os.path.join("output",epub_file_name + "_pageimages")
epub_file_path = os.path.join("output",epub_file_name + "_html.epub")
epub_file_path_pageimages = os.path.join("output",epub_file_name + "_pageimages.epub")

def write_mimetype_file(output_folder):
    mimetype_path = os.path.join(output_folder, "mimetype")
    with open(mimetype_path, "w", encoding="utf-8") as f:
        f.write("application/epub+zip")

def generate_font_list(folder_path):
    font_array = []
    for file_name in os.listdir(folder_path):
        if file_name.endswith(".ttf"):  # Check if the file is a TrueType font
            font_name = os.path.splitext(file_name)[0]  # Remove the '.ttf' extension
            font_path = os.path.join(folder_path, file_name)
            font_array.append({
                "font_name": font_name,
                "font_path": font_path
            })
    return font_array

font_list = generate_font_list(font_folder)
fonts_in_pdf = []

def write_meta_inf_container_xml(meta_inf_folder):
    """Write the META-INF/container.xml file"""
    container_path = os.path.join(meta_inf_folder, "container.xml")
    container_content = """<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
    <rootfiles>
        <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
    </rootfiles>
</container>
"""
    with open(container_path, "w", encoding="utf-8") as f:
        f.write(container_content)

def write_content_opf(oebps_folder,content_opf_items,page_html_files,variant):
    """Write OEBPS/content.opf"""
    content_opf_path = os.path.join(oebps_folder, "content.opf")
    font_items = ""
    if variant == "html" :
        for font in font_list:
            font_items += f'<item id="font" href="{font["font_path"]}" media-type="application/x-font-ttf"/>\n'       
    content_opf_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<package version="3.0" xmlns="http://www.idpf.org/2007/opf" unique-identifier="bookid" prefix="rendition: http://www.idpf.org/vocab/rendition/# ibooks: http://vocabulary.itunes.apple.com/rdf/ibooks/vocabulary-extensions-1.0/">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
        <meta name="generator" content="pdf2epub3fixed" />
        <meta property="ibooks:specified-fonts">true</meta>
        <dc:title>{title}</dc:title>
        <dc:creator id="creator">{author}</dc:creator>
        <meta refines="#creator" property="role" scheme="marc:relators">aut</meta>
        <dc:language>{language}</dc:language>
        <dc:publisher>{publisher}</dc:publisher>
        <dc:date>{date}</dc:date>
        <dc:description>{description}</dc:description>
        <dc:rights>{rights}</dc:rights>
        <dc:identifier id="bookid">urn:uuid:{urn}</dc:identifier>
        <meta name="cover" content="book-cover" />
        <meta property="dcterms:modified">{datetime.now().strftime('%Y-%m-%dT%H:%M:%SZ')}</meta>
        <!--fixed-layout options-->
		<meta property="rendition:layout">pre-paginated</meta>
		<meta property="rendition:orientation">portrait</meta>
		<meta property="rendition:spread">none</meta>
    </metadata>
    <manifest>
        <item id="toc" href="toc.ncx" media-type="application/x-dtbncx+xml" properties="nav"/>
        <item id="css" href="style.css" media-type="text/css"/>
        {font_items}
        {"".join(content_opf_items)}
    </manifest>
    <spine toc="toc">
        {"".join(page_html_files)}
    </spine>
</package>
"""
    with open(content_opf_path, "w", encoding="utf-8") as f:
        f.write(content_opf_content)

def write_toc_ncx(oebps_folder, doc):
    toc_ncx_path = os.path.join(oebps_folder, "toc.ncx")
    toc = doc.get_toc() # [[1, 'Préface', 7], [1, 'Les deux mélodies fondamentales', 17], ...]
    toc_ncx_points = []
    for chapnum, t in enumerate(toc) :
        toc_ncx_points.append(f"""
        <navPoint id="chapter-{chapnum + 1}" playOrder="{chapnum + 1}">
            <navLabel>
                <text>{t[1]}</text>
            </navLabel>
            <content src="page_{t[2]}.xhtml"/>
        </navPoint>
        """)
    toc_ncx_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
    <head>
        <meta name="dtb:uid" content="urn:uuid:12345678-1234-1234-1234-123456789abc"/>
        <meta name="dtb:depth" content="1"/>
        <meta name="dtb:totalPageCount" content="{doc.page_count}"/>
        <meta name="dtb:maxPageNumber" content="{doc.page_count}"/>
    </head>
    <docTitle>
        <text>{title}</text>
    </docTitle>
    <navMap>
        {"".join(toc_ncx_points)}
    </navMap>
</ncx>
"""
    with open(toc_ncx_path, "w", encoding="utf-8") as f:
        f.write(toc_ncx_content)

def write_css_and_font_files(oebps_folder,font_folder_output,variant):
        # Step 8: Add a CSS file with @font-face
    css_path = os.path.join(oebps_folder, "style.css")
    css_content = ""
    if variant == "html" :
        for font in font_list :
            css_content += f"""@font-face {{
        font-family: \"{font['font_name']}\";
        font-style: normal;
        font-weight: 300;
        src: url(\"font['font_path']\");
    }}"""
    css_content += """body, div, dl, dt, dd, h1, h2, h3, h4, h5, h6, p, pre, code, blockquote, figure {
	margin:0;
	padding:0;
	border-width:0;
	text-rendering:optimizeSpeed;
}
div { position: absolute; }
img { position: absolute; }
"""
    with open(css_path, "w", encoding="utf-8") as f:
        f.write(css_content)
    if variant == "html" :
        for font in font_list : 
            font_path = os.path.join(font_folder_output, f"{font['font_name']}.ttf")
            shutil.copyfile(font_folder + f"/{font['font_name']}.ttf", font_path)

def extract_crosslinks(page):
    """Extract crosslinks using page.get_links() and add them to JSON"""
    links = []
    for link in page.get_links():
        rect = link.get('from')
        point = link.get('to')
        links.append({
            "kind" : link.get('kind'), 
            "xref" : link.get('xref'),  
            "uri" : link.get('uri'),
            "nameddest": link.get('nameddest'),
            "id" : link.get('id'),
            "zoom" : link.get('zoom'),
            "page" : link.get('page'),
            "to" : [point.x, point.y] if point else None,
            "rect": [rect.x0, rect.y0, rect.x1, rect.y1] if rect else None
        })
    return links
    

def extract_pdf_to_json(doc, output_json_path):
    """Extracts all pages of a PDF as JSON and writes to a file."""
    pages_data = []
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        page_dict = page.get_text("dict")  # Extract page data in dict format        
        # Process blocks to handle binary data
        for block in page_dict.get("blocks", []):
            if "image" in block and isinstance(block["image"], bytes):
                # Convert image bytes to base64 string
                block["image"] = base64.b64encode(block["image"]).decode("utf-8")
        crosslinks = extract_crosslinks(page)  
        page_data = {
            "page_num": page_num + 1,  # Human-readable page number
            "content": page_dict,
            "crosslinks": crosslinks
        }
        pages_data.append(page_data)
    with open(output_json_path, "w", encoding="utf-8") as json_file:
        json.dump(pages_data, json_file, indent=4, ensure_ascii=False)
    print(f"PDF content extracted and saved to {output_json_path}")

def create_epub_structure_from_pdf(pdf_path, output_folder, variant, generate_json = True):    
    """Creates the folder structure and files needed for a fixed-layout EPUB from a PDF. Depending on the variant, generate a HTML based version with selectable texte or a version consisting of image renderings of the PDF"""
    os.makedirs(output_folder, exist_ok=True)
    meta_inf_folder = os.path.join(output_folder, "META-INF")
    os.makedirs(meta_inf_folder, exist_ok=True)
    oebps_folder = os.path.join(output_folder, "OEBPS")
    os.makedirs(oebps_folder, exist_ok=True)
    if variant == "html" : 
        font_folder_output = os.path.join(oebps_folder, "font")
        os.makedirs(font_folder_output, exist_ok=True)
    else: 
        font_folder_output = ""
    images_folder = os.path.join(oebps_folder, "image")
    os.makedirs(images_folder, exist_ok=True)
    write_mimetype_file(output_folder)
    write_meta_inf_container_xml(meta_inf_folder)

    # Initialize content.opf and toc.ncx content
    content_opf_items = []
    page_html_files = []

    # Loop through PDF pages and generate HTML
    doc = fitz.open(pdf_path)
    if generate_json : 
        print("Extracting also the PDF structure as raw JSON data for verification")
        extract_pdf_to_json(
            doc,
            os.path.join("output", epub_file_name + "_rawstructure.json")
        )
    image_counter = 0
    for page_num in range(doc.page_count):
        print("processing page " + str(page_num))
        page = doc.load_page(page_num)
        html_file_name = f"page_{page_num + 1}.xhtml"
        html_file_path = os.path.join(oebps_folder, html_file_name)
        # Generate fixed-layout HTML for the page
        if variant == "html" :
            page_html, image_counter, image_manifest = generate_fixed_layout_html_selectable(
                page, page_num, images_folder, image_counter
            )
        else :
            page_html, image_counter, image_manifest = generate_fixed_layout_html(
                page, page_num, images_folder, image_counter
            )
        with open(html_file_path, "w", encoding="utf-8") as f:
            f.write(page_html)
        # Add to manifest and toc
        content_opf_items.append(
            f'<item id="page_{page_num + 1}" href="{html_file_name}" media-type="application/xhtml+xml"/>\n'
        )
        for img in image_manifest:
            content_opf_items.append(
                f'<item id="{img['id']}" href="{img['href']}" media-type="image/png"/>\n'
            )
        page_html_files.append(f'<itemref idref="page_{page_num + 1}"/>\n')
       
    # Add a cover image if available  
    if os.path.exists(cover_image) :
        cover_image_destination = os.path.join(images_folder, cover_image)
        shutil.copy2(cover_image, cover_image_destination)
        content_opf_items.append(
                f'<item id="book-cover" href="image/{cover_image}" media-type="image/png"/>\n'
            )
    else : print("Your book has no cover image.")

    if variant == "html":
        print("Verify if you have all the fonts actually used in the PDF. Add them if necessary, using these exact names:")
        for fnt in fonts_in_pdf:
            print(fnt)
    write_content_opf(oebps_folder,content_opf_items,page_html_files,variant)
    write_toc_ncx(oebps_folder, doc)
    write_css_and_font_files(oebps_folder,font_folder_output,variant)
    print(f"EPUB structure created at: {output_folder}")

def process_red_boxes_links(frompage, html_content):
    """Extracts red boxes with links and adds them as cross-references in HTML."""
    for link in frompage.get_links():
        rect = link.get('from')
        point = link.get('to')
        topage = link.get('page')
        kind = link.get('kind') 
        xref = link.get('xref')  
        uri = link.get('uri')
        nameddest = link.get('nameddest')
        id = link.get('id')
        zoom = link.get('zoom')
        to = [point.x, point.y] if point else None,
        width = rect.x1 - rect.x0
        height = rect.y1 - rect.y0
        if topage is not None:
            html_content += f'<a href="page_{topage + 1}.xhtml" style="position:absolute; left:{rect.x0}px; top:{rect.y0}px; width:{width}px; height:{height}px; border:0.5px solid red; display:block;"></a>\n'
        else :
            html_content += f'<a href="{uri}" style="position:absolute; left:{rect.x0}px; top:{rect.y0}px; width:{width}px; height:{height}px; border:0.5px solid red; display:block;"></a>\n' 
    return html_content

def is_all_caps(text):
  """
  Checks if the given text is entirely in uppercase. There is no way to extract smallcaps status from pdf, so using this as fallback 
  """
  for char in text:
    if not char.isalpha() or not char.isupper() or char in ["."," ",","]:
      return False
  return True

def generate_fixed_layout_html(page, page_num, images_folder, image_counter, dpi=300):
    """
    Generates fixed-layout HTML for a single PDF page by rendering the page as an image.
    """
    html_content = f"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width={page.rect.width},height={page.rect.height}" />
    <title>Page {page_num + 1}</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body style="width:{page.rect.width}px;height:{page.rect.height}px; position:relative;">
"""

    # Render the PDF page as an image
    pix = page.get_pixmap(dpi=dpi)
    image_filename = f"page_{page_num + 1}.png"
    image_path = os.path.join(images_folder, image_filename)
    pix.save(image_path)

    # Add the rendered page image to the HTML content
    html_content += f"""<img src="image/{image_filename}" style="position:absolute; left:0px; top:0px; width:{page.rect.width}px; height:{page.rect.height}px;" />\n"""

    html_content = process_red_boxes_links(page, html_content)
    html_content += "</body></html>"

    # Update image manifest
    image_manifest = [{
        'id': f"image_{image_counter}",
        'href': f"image/{image_filename}"
    }]
    image_counter += 1

    return html_content, image_counter, image_manifest


def generate_fixed_layout_html_selectable(page, page_num, images_folder, image_counter):
    """Generates fixed-layout HTML for a single PDF page, including images. Using get_text("dict") and get_text("words"). Is difficult to make work, because the word splitting and the span splitting inside words sometimes overlap"""
    html_content = f"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width={page.rect.width},height={page.rect.height}" />
    <title>Page {page_num + 1}</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body style="width:{page.rect.width}px;height:{page.rect.height}px; position:relative;">
"""  
    text_instances = page.get_text("rawdict")  # Extract layout-based text

    # Extract words and their bounding boxes
    if "blocks" in text_instances:
        for block_no, block in enumerate(text_instances["blocks"]):
            if "lines" in block:
                for line_no, line in enumerate(block["lines"]):
                    for span in line["spans"]:
                        font_name = span["font"]
                        if font_name not in fonts_in_pdf:
                            fonts_in_pdf.append(font_name)
                        font_size = span["size"]
                        words = []
                        current_word = ""
                        first_letter_start_x = None
                        first_letter_start_y = None
                        for char_data in span['chars']:
                            char = char_data['c'] # {'origin': (80.331, 222.817), 'bbox': (80.3, 213.5, 86.6, 225.3), 'c': 'A'}, 
                            if char != ' ' :
                                if not current_word:  # If the word is empty, i.e. new, start of a new word delimiter
                                    first_letter_start_x = char_data['bbox'][0]
                                    first_letter_start_y = char_data['bbox'][1]
                                current_word += char
                            else :
                                if current_word:  # Since the new character is a space, we can add the current word to the list of words
                                    last_letter_end_x = char_data['bbox'][2]
                                    last_letter_end_y = char_data['bbox'][3]
                                    words.append({
                                        'word': current_word, 
                                        'bbox': (first_letter_start_x, first_letter_start_y, last_letter_end_x, last_letter_end_y)
                                    })
                                    current_word = ""
                                    first_letter_start_x = None
                                    first_letter_start_y = None
                                    words.append({'word': ' ', 'bbox': char_data['bbox']}) # Add space as a word
                        # Add the last word if there is any
                        if current_word:
                            last_letter_end_x = char_data['bbox'][2]
                            last_letter_end_y = char_data['bbox'][3]
                            words.append({
                                'word': current_word, 'bbox': (first_letter_start_x, first_letter_start_y, last_letter_end_x, last_letter_end_y)
                            })
                        # span_x0, span_y0, span_x1, span_y1 = span["bbox"]
                        for word in words :
                            word_text = word['word']
                            x0, y0, x1, y1 = word['bbox']
                            width = x1 - x0
                            height = y1 - y0
                            word_text = word_text.replace('&', '&amp;').replace(u'\u00A0', '&nbsp;')
                            if len(word_text) > 1 and page_num > 353 :
                                if is_all_caps(word_text):
                                    word_text = f"<span style='font-variant:small-caps'>{word_text[0] + word_text[1:].lower()}</span>"
                                    print(word_text) 
                            html_content += f"""<div style="position:absolute; left:{x0}px; top:{y0}px; width:{width}px; height:{height}px; font-family:'{font_name}'; font-size:{font_size}px; white-space:nowrap;">{word_text}</div>\n"""
    html_content, image_manifest, image_counter = process_images(text_instances, images_folder, image_counter, html_content)
    html_content = process_red_boxes_links(page, html_content)
    html_content += "</body></html>"
    return html_content, image_counter, image_manifest


def process_images(text_instances, images_folder, image_counter, html_content) :
    """Process images on the page and prepare the listing of images in the manifest. Only used in compelx HTML layout"""
    image_manifest= []
    if 'blocks' in text_instances:
        for block in text_instances['blocks']:
            if 'image' in block :
                if isinstance(block['image'], bytes):
                    # Extract and save image
                    image_data = block['image']
                    image = Image.open(io.BytesIO(image_data))
                    image_filename = f"image_{image_counter}.png"
                    image_path = os.path.join(images_folder, image_filename)
                    image.save(image_path, format="PNG")
                    # Add the image to the manifest
                    image_manifest.append({
                        'id': f"image_{image_counter}",
                        'href': f"image/{image_filename}"
                    })
                    # Get image position and dimensions
                    x0, y0, x1, y1 = block['bbox']
                    width = x1 - x0
                    height = y1 - y0
                    html_content += f'<figure id="_image_{image_counter}"><img src="image/{image_filename}" style="left:{x0}px; top:{y0}px; width:{width}px; height:{height}px;" />\n</figure>'
                    image_counter += 1
                elif isinstance(block['image'], str) and block['image'].strip().startswith("<svg"):
                    # Handle SVG images
                    svg_data = block['image']
                    image_filename = f"image_{image_counter}.svg"
                    image_path = os.path.join(images_folder, image_filename)
                    # Save the SVG data to a file
                    with open(image_path, 'w', encoding='utf-8') as svg_file:
                        svg_file.write(svg_data)               
                    # Add the SVG to the manifest
                    image_manifest.append({
                        'id': f"image_{image_counter}",
                        'href': f"image/{image_filename}"
                    })
                    image_counter += 1
                else:
                    continue  # Skip unsupported image formats
    return html_content, image_manifest, image_counter 

def zip_folder_to_epub(folder_path, epub_path):
    """Zips the folder structure and creates an EPUB file."""
    epub_temp_path = epub_path + ".zip"
    with zipfile.ZipFile(epub_temp_path, 'w', zipfile.ZIP_DEFLATED) as epub_zip:
        # Add mimetype first (must be uncompressed)
        mimetype_path = os.path.join(folder_path, "mimetype")
        epub_zip.write(mimetype_path, "mimetype", compress_type=zipfile.ZIP_STORED)
        # Add the rest of the files
        for root, _, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                archive_path = os.path.relpath(file_path, folder_path)
                if archive_path != "mimetype":  # mimetype already added
                    epub_zip.write(file_path, archive_path)

    # Rename the zip file to .epub
    os.rename(epub_temp_path, epub_path)
    print(f"EPUB file created at: {epub_path}")

# html version
print("Creating HTML version with selectable text")
create_epub_structure_from_pdf(pdf_path, output_folder_html,"html",True)
zip_folder_to_epub(output_folder_html, epub_file_path)

# pageimages version
print("Creating version consiting of PAGE IMAGES")
create_epub_structure_from_pdf(pdf_path, output_folder_pageimages,"pageimages",False)
zip_folder_to_epub(output_folder_pageimages, epub_file_path_pageimages)
